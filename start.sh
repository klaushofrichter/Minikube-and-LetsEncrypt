#!/bin/bash
set -e

export PUBLICURL="your.domain.com"
export EMAIL="your.name@emailprovider.com"
export CERTLEVEL="stage"  # use "stage" or "prod". stay with "stage" when in doubt :-)

# See details here: https://medium.com/@klaushofrichter/minikube-and-lets-encrypt-6e407aabb8ac

# no need to change anything below #
MAC="2221d707e6c1"  # generated by https://miniwebtool.com/mac-address-generator/
export KUBECONFIG="kubectl.config"
export NAMESPACE="my-app"
export CLUSTER="my-cluster"

[ "${PUBLICURL}" = "your.domain.com" ] && echo "Please change PUBLICURL in $0" && exit 1
[ "${EMAIL}" = "your.name@emailprovider.com" ] && echo "Please change EMAIL in $0" && exit 1

minikube -p ${CLUSTER} delete || true  # providing a clean start
minikube -p ${CLUSTER} --driver=virtualbox start

VBoxManage controlvm ${CLUSTER} poweroff
nic=$( VBoxManage showvminfo ${CLUSTER} --machinereadable | grep ^nic | grep '"none"' | head -n1 | cut -d= -f1 | cut -c4- )
interface=$(ip route | grep default | awk '{ print $5 }')
opts="--macaddress${nic} ${MAC}"
VBoxManage modifyvm ${CLUSTER} --nic${nic} bridged --bridgeadapter${nic} ${interface} ${opts}
minikube -p ${CLUSTER} start
VBIP=$(minikube ssh -p ${CLUSTER} -- ip addr show eth2 | grep inet | awk '{ print $2 }' | cut -d/ -f1)
echo "virtualbox exposed LAN ip is ${VBIP}"

minikube -p ${CLUSTER} addons enable ingress
kubectl delete validatingwebhookconfigurations ingress-nginx-admission  # otherwise ingresses won't install

kubectl create namespace ${NAMESPACE}
cat hello.yaml.template | envsubst | kubectl create --save-config -f -
cat welcome.yaml.template | envsubst | kubectl create --save-config -f -

cat insecure-ingress.yaml.template | envsubst | kubectl create --save-config -f -
sleep 60 # short remaining wait for ingress to setup everything

curl ${PUBLICURL}/hello  # test the insecure ingress

kubectl create -f https://github.com/jetstack/cert-manager/releases/download/v1.3.1/cert-manager.yaml --save-config
sleep 120  # wait for certmanager pods to launch
kubectl get pods -n cert-manager  # this should show three pods running

[ -f ${CERTLEVEL}-${PUBLICURL}-cert.yaml ] && kubectl apply -f ${CERTLEVEL}-${PUBLICURL}-cert.yaml  # install client cert when available

cat ${CERTLEVEL}-clusterissuer.yaml.template | envsubst | kubectl apply -f -
sleep 60 # wait for the cluster issuer to figure things out

cat secure-ingress.yaml.template | envsubst | kubectl apply -f -
sleep 60 # short wait for ingress to setup everything
[ ! -f ${CERTLEVEL}-${PUBLICURL}-cert.yaml ] && sleep 300  #  extra long wait for Let's Encrypt HTTP Challenge if there is no cert yet

if [[ "${CERTLEVEL}" = "stage" ]]; then
  [ ! -f caroot.pem ] && curl -s http://stg-x1.i.lencr.org | openssl x509 -inform der -out caroot.pem
  openssl x509 -noout -in caroot.pem -subject -dates
  curl -L --cacert caroot.pem http://${PUBLICURL}/hello
  curl --cacert caroot.pem https://${PUBLICURL}/welcome
else
  curl -L http://${PUBLICURL}/hello   # need -L for the redirect from http-->https even with prod client cert
  curl https://${PUBLICURL}/welcome    
fi

[ ! -f ${CERTLEVEL}-${PUBLICURL}-cert.yaml ] && kubectl -n ${NAMESPACE} get -o yaml secret ${NAMESPACE}-tls > ${CERTLEVEL}-${PUBLICURL}-cert.yaml
exit 0
